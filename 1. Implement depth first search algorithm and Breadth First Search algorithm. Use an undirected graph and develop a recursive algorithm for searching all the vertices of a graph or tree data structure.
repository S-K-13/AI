1. DEPTH FIRST SEARCH (DFS):

def dfs(graph, node, visited, traversal):
    visited.add(node)
    traversal.append(node)
    for neighbor in graph.get(node, []):
        if neighbor not in visited:
            dfs(graph, neighbor, visited, traversal)

def main():
    graph = {}

    while True:
        print("\nDFS Menu:")
        print("1. Add edge (undirected)")
        print("2. Show graph")
        print("3. Perform DFS Traversal")
        print("4. Exit")

        choice = input("Enter your choice: ")

        if choice == '1':
            u = input("Enter vertex 1: ")
            v = input("Enter vertex 2: ")

            if u not in graph:
                graph[u] = []
            if v not in graph:
                graph[v] = []

            graph[u].append(v)
            graph[v].append(u)
            print(f"Edge added between {u} and {v}")

        elif choice == '2':
            print("Graph adjacency list:")
            for node in graph:
                print(f"{node}: {graph[node]}")

        elif choice == '3':
            start = input("Enter starting vertex for DFS: ")
            if start not in graph:
                print("Vertex not found in graph.")
            else:
                visited = set()
                traversal = []
                dfs(graph, start, visited, traversal)
                print("DFS Traversal Order:", traversal)

        elif choice == '4':
            print("Exiting DFS program...")
            break

        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    main()




2. BREADTH FIRST SEARCH (BFS):


from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    traversal = []
    visited.add(start)

    while queue:
        node = queue.popleft()
        traversal.append(node)
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    return traversal

def main():
    graph = {}

    while True:
        print("\nBFS Menu:")
        print("1. Add edge (undirected)")
        print("2. Show graph")
        print("3. Perform BFS Traversal")
        print("4. Exit")

        choice = input("Enter your choice: ")

        if choice == '1':
            u = input("Enter vertex 1: ")
            v = input("Enter vertex 2: ")

            if u not in graph:
                graph[u] = []
            if v not in graph:
                graph[v] = []

            graph[u].append(v)
            graph[v].append(u)
            print(f"Edge added between {u} and {v}")

        elif choice == '2':
            print("Graph adjacency list:")
            for node in graph:
                print(f"{node}: {graph[node]}")

        elif choice == '3':
            start = input("Enter starting vertex for BFS: ")
            if start not in graph:
                print("Vertex not found in graph.")
            else:
                traversal = bfs(graph, start)
                print("BFS Traversal Order:", traversal)

        elif choice == '4':
            print("Exiting BFS program...")
            break

        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    main()



üß† 1. Depth-First Search (DFS)

This program performs Depth-First Search on an undirected graph using recursion.

The graph is stored as an adjacency list (a dictionary where each key is a vertex and its value is a list of connected vertices).

The function dfs(graph, node, visited, traversal) explores all nodes starting from a given vertex.

It marks the current node as visited (visited.add(node)),

Appends it to the traversal list to record visit order, and

Recursively calls dfs() on every unvisited neighbor.

The main() function shows a simple menu system where users can add undirected edges, display the adjacency list, and perform DFS.

Because it uses recursion, DFS goes deep into one path first before backtracking, ensuring all connected vertices are explored.

Time complexity: O(V + E) where V = vertices, E = edges.

Space complexity: O(V) due to the recursion stack and the visited set.

‚öôÔ∏è 2. Breadth-First Search (BFS)

The BFS program explores the same undirected graph but in level order using a queue from the collections.deque module.

The bfs(graph, start) function starts with a given vertex, marks it as visited, and pushes it into the queue.

Then, while the queue is not empty, it pops the front node, adds it to the traversal list, and pushes all unvisited neighbors into the queue.

This ensures nodes are visited layer by layer, discovering all vertices that are one edge away before moving deeper.

The main() function again provides a menu where the user can add edges, view the graph, and run BFS traversal.

Unlike DFS, BFS uses iteration, not recursion, and is ideal for finding the shortest path in an unweighted graph.

Time complexity: O(V + E); Space complexity: O(V) because of the queue and visited set.
