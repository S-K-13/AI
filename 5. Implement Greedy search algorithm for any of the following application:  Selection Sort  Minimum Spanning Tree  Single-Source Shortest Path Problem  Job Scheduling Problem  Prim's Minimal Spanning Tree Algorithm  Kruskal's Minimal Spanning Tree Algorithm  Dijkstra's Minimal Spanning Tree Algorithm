5.1. SELECTION SORT:

def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_index = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]

def main():
    arr = []
    while True:
        print("\n----- Menu -----")
        print("1. Enter elements")
        print("2. Sort using Selection Sort")
        print("3. Display array")
        print("4. Exit")


        choice = input("Enter your choice: ")

        if choice == '1':
            arr = []
            n = int(input("How many numbers do you want to enter? "))
            for i in range(n):
                num = int(input(f"Enter number {i+1}: "))
                arr.append(num)
        elif choice == '2':
            selection_sort(arr)
            print("Array sorted successfully.")
        elif choice == '3':
            print("Current array:", arr)
        elif choice == '4':
            print("Exiting program.")
            break
        else:
            print("Invalid choice. Try again.")

if __name__ == "__main__":
    main()


5.2. MINIMUM SPANNING TREE:

def find_min_vertex(key, visited, V):
    min_val = float('inf')
    min_index = -1
    for i in range(V):
        if not visited[i] and key[i] < min_val:
            min_val = key[i]
            min_index = i
    return min_index

def prim_mst(graph, V):
    key = [float('inf')] * V
    parent = [-1] * V
    visited = [False] * V

    key[0] = 0 

    for _ in range(V):
        u = find_min_vertex(key, visited, V)
        visited[u] = True

        for v in range(V):
            if graph[u][v] != 0 and not visited[v] and graph[u][v] < key[v]:
                key[v] = graph[u][v]
                parent[v] = u

    print("\n Minimum Spanning Tree (MST):")
    print("Edge\tWeight")
    total = 0
    for i in range(1, V):
        # Adding 1 to vertex numbers for user-friendly output
        print(f"{parent[i]+1} - {i+1}\t{graph[i][parent[i]]}")
        total += graph[i][parent[i]]
    print("Total weight of MST:", total)

def main():
    graph = []
    V = 0

    while True:
        print("\n----- Menu -----")
        print("1. Enter Graph (Adjacency Matrix)")
        print("2. Find Minimum Spanning Tree")
        print("3. Exit")

        choice = input("Enter your choice: ")

        if choice == '1':
            graph = []
            V = int(input("Enter number of vertices: "))
            print("Enter adjacency matrix row by row (use 0 if no edge):")
            for i in range(V):
                row_input = input(f"Row {i+1}: ").split()
                if len(row_input) != V:
                    print(" Please enter exactly", V, "values.")
                    break
                row = list(map(int, row_input))
                graph.append(row)
            else:
                print(" Graph saved successfully.")

        elif choice == '2':
            if not graph:
                print("️ Graph not entered yet. Please enter graph first.")
            else:
                prim_mst(graph, V)

        elif choice == '3':
            print("Exiting program. ")
            break

        else:
            print(" Invalid choice. Try again.")

if __name__ == "__main__":
    main()

5.3. MINIMUM SPANNING TREE (KRUSKAL’S):

def find_parent(parent, node):
    if parent[node] == node:
        return node
    return find_parent(parent, parent[node])

def union(parent, u, v):
    parent_u = find_parent(parent, u)
    parent_v = find_parent(parent, v)
    parent[parent_v] = parent_u

def kruskal(vertices, edges):
    edges.sort(key=lambda x: x[2])  # Sort by weight
    parent = {v: v for v in vertices}
    mst = []
    total_weight = 0

    for u, v, w in edges:
        if find_parent(parent, u) != find_parent(parent, v):
            mst.append((u, v, w))
            total_weight += w
            union(parent, u, v)

    return mst, total_weight

def main():
    vertices = []
    edges = []

    while True:
        print("\n--- MENU ---")
        print("1. Add Vertex")
        print("2. Add Edge")
        print("3. Show Graph")
        print("4. Find MST (Kruskal's Algorithm)")
        print("5. Exit")

        choice = input("Enter your choice: ")

        if choice == '1':
            v = input("Enter vertex: ")
            if v not in vertices:
                vertices.append(v)
                print("Vertex added.")
            else:
                print("Vertex already exists.")

        elif choice == '2':
            u = input("Enter first vertex: ")
            v = input("Enter second vertex: ")
            w = int(input("Enter edge weight: "))
            edges.append((u, v, w))
            print("Edge added.")

        elif choice == '3':
            print("Vertices:", vertices)
            print("Edges:")
            for edge in edges:
                print(edge)

        elif choice == '4':
            if len(vertices) == 0 or len(edges) == 0:
                print("Graph is empty. Please add vertices and edges.")
            else:
                mst, weight = kruskal(vertices, edges)
                print("\nMinimum Spanning Tree:")
                for u, v, w in mst:
                    print(f"{u} -- {v} : {w}")
                print("Total Weight:", weight)

        elif choice == '5':
            print("Goodbye!")
            break

        else:
            print("Invalid choice. Try again.")

if __name__ == "__main__":
    main()

5.4. JOB SCHEDULING PROBLEM:

def job_scheduling(jobs, max_deadline):
    # Sort jobs by profit in descending order
    jobs.sort(key=lambda job: job[2], reverse=True)

    # Create time slots to schedule jobs
    slots = [None] * max_deadline
    total_profit = 0
    scheduled_jobs = []

    for job_id, deadline, profit in jobs:
        # Try to schedule the job in the latest possible free slot
        for slot in range(min(deadline, max_deadline) - 1, -1, -1):
            if slots[slot] is None:
                slots[slot] = job_id
                total_profit += profit
                scheduled_jobs.append(job_id)
                break

    return scheduled_jobs, total_profit


def main():
    jobs = []

    while True:
        print("\n--- Job Scheduling Menu ---")
        print("1. Add Job")
        print("2. Schedule Jobs")
        print("3. Show All Jobs")
        print("4. Exit")
        choice = input("Enter your choice (1-4): ")

        if choice == '1':
            job_id = input("Enter Job ID (e.g. A): ")
            deadline = int(input("Enter Deadline (e.g. 2): "))
            profit = int(input("Enter Profit (e.g. 100): "))
            jobs.append((job_id, deadline, profit))
            print("Job added successfully!")

        elif choice == '2':
            if not jobs:
                print("No jobs to schedule. Please add jobs first.")
                continue
            max_deadline = int(input("Enter maximum deadline for scheduling: "))
            scheduled, profit = job_scheduling(jobs, max_deadline)
            print("\nScheduled Jobs:", scheduled)
            print("Total Profit:", profit)

        elif choice == '3':
            if not jobs:
                print("No jobs added yet.")
            else:
                print("\nCurrent Job List:")
                for job in jobs:
                    print(f"ID: {job[0]}, Deadline: {job[1]}, Profit: {job[2]}")

        elif choice == '4':
            print("Exiting... Thank you!")
            break

        else:
            print("Invalid choice. Please enter 1-4.")


if __name__ == "__main__":
    main()

5.5. DIJKSTRA’S MINIMAL SPANNING TREE:

def dijkstra(graph, start):
    visited = set()
    distances = {vertex: float('inf') for vertex in graph}
    distances[start] = 0
    
    while visited != set(graph.keys()):
        
        min_vertex = None
        for vertex in graph:
            if vertex not in visited:
                if min_vertex is None or distances[vertex] < distances[min_vertex]:
                    min_vertex = vertex
        
        if distances[min_vertex] == float('inf'):
            break
        
        visited.add(min_vertex)
        
        for neighbor, weight in graph[min_vertex].items():
            if neighbor not in visited:
                new_distance = distances[min_vertex] + weight
                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance
    
    return distances


def main():
    graph = {}
    
    while True:
        print("\nMenu:")
        print("1. Add edge")
        print("2. Show graph")
        print("3. Find shortest path (Dijkstra's algorithm)")
        print("4. Exit")
        
        choice = input("Enter your choice: ")
        
        if choice == '1':
            u = input("Enter start vertex: ")
            v = input("Enter end vertex: ")
            w = float(input("Enter weight of edge: "))
            
            if u not in graph:
                graph[u] = {}
            if v not in graph:
                graph[v] = {}
            
            graph[u][v] = w
              
            print(f"Edge added: {u} --{w}--> {v}")
        
        elif choice == '2':
            print("Graph:")
            for u in graph:
                for v in graph[u]:
                    print(f"{u} --{graph[u][v]}--> {v}")
        
        elif choice == '3':
            start = input("Enter the start vertex: ")
            if start not in graph:
                print("Start vertex not in graph!")
            else:
                distances = dijkstra(graph, start)
                print("Shortest distances from vertex", start)
                for vertex in distances:
                    print(f"{vertex}: {distances[vertex]}")
        
        elif choice == '4':
            print("Exiting...")
            break
        
        else:
            print("Invalid choice, try again.")

if __name__ == "__main__":
    main()

5.6. SINGLE-SOURCE SHORTEST PATH:


def dijkstra(graph, start):
   
    distances = {vertex: float('inf') for vertex in graph}
    distances[start] = 0  
    
    visited = set()
    
    while len(visited) < len(graph):
        
        min_vertex = None
        for vertex in graph:
            if vertex not in visited:
                if min_vertex is None or distances[vertex] < distances[min_vertex]:
                    min_vertex = vertex
        
        if distances[min_vertex] == float('inf'):
            break  
        
        visited.add(min_vertex)
        
        
        for neighbor, weight in graph[min_vertex].items():
            if neighbor not in visited:
                new_distance = distances[min_vertex] + weight
                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance
    
    return distances

def main():
    graph = {}
    
    while True:
        print("\nMenu:")
        print("1. Add edge")
        print("2. Show graph")
        print("3. Find shortest path from source")
        print("4. Exit")
        
        choice = input("Enter your choice: ")
        
        if choice == '1':
            u = input("Enter start vertex: ")
            v = input("Enter end vertex: ")
            w = float(input("Enter weight of edge: "))
            
            if u not in graph:
                graph[u] = {}
            if v not in graph:
                graph[v] = {}
            
            graph[u][v] = w
            
            print(f"Edge added: {u} --{w}--> {v}")
        
        elif choice == '2':
            print("Graph:")
            for u in graph:
                for v in graph[u]:
                    print(f"{u} --{graph[u][v]}--> {v}")
        
        elif choice == '3':
            start = input("Enter the source vertex: ")
            if start not in graph:
                print("Source vertex not found in graph!")
            else:
                distances = dijkstra(graph, start)
                print(f"Shortest distances from vertex {start}:")
                for vertex, distance in distances.items():
                    print(f"{vertex}: {distance}")
        
        elif choice == '4':
            print("Exiting...")
            break
        
        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    main()


